<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[新的开始]]></title>
    <url>%2FDiary%2F%E6%96%B0%E7%9A%84%E5%BC%80%E5%A7%8B%2F</url>
    <content type="text"><![CDATA[如果还没有开始就AFO了话，那也太不甘心了吧。 NOIP2017还有61天，]]></content>
      <categories>
        <category>Diary</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[hello-world]]></title>
    <url>%2FGeek%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to 葛伟杰’Blog——————————————————— 2017.9.2 Test hexo搭建的静态页面，网站资料托管在Github上 从本周起开始搬运原博客地址：http://gwj1314.azurewebsites.net/ 2017.9.3因为时间原因只占了个坑尚未完成搭建美化及部署还待更新。 2017.9.10 看完了官方的说明文档，修改了博客界面搬运了以前的部分文章，不过考虑到实际情况旧版的时间和内容都不大可靠，甚至可以说，没法看，目前只用来凑数]]></content>
      <categories>
        <category>Geek</category>
      </categories>
      <tags>
        <tag>VPS</tag>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown语法]]></title>
    <url>%2FGeek%2FMarkdown%E8%AF%AD%E6%B3%95%E7%A0%94%E7%A9%B6%2F</url>
    <content type="text"><![CDATA[针对中文,演示Markdown的各种语法转自https://github.com/guoyunsky/Markdown-Chinese-Demo 大标题 大标题一般显示工程名,类似html的\ 你只要在标题下面跟上=====即可 中标题 中标题一般显示重点项,类似html的\ 你只要在标题下面输入——即可 小标题 小标题类似html的\ 小标题的格式如下 ### 小标题 注意#和标题字符中间要有空格 标题的等级表示法关于标题的等级表示法，共分为六个等级，显示的文本大小依次减小。不同等级之间以井号#的个数来标识。一级标题有一个#，二级标题有两个#，以此类推。 #一级标题 ##二级标题 ###三级标题 ####四级标题 #####五级标题 ######六级标题 注意!!!下面所有语法的提示我都先用小标题提醒了!!!单行文本框这是一个单行的文本框,只要两个Tab再输入文字即可 多行文本框这是一个有多行的文本框 你可以写入代码等,每行文字只要输入两个Tab再输入文字即可 这里你可以输入一段代码 比如我们可以在多行文本框里输入一段代码,来一个Java版本的HelloWorld吧public class HelloWorld { /** * @param args */ public static void main(String[] args) { System.out.println(&quot;HelloWorld!&quot;); } } 链接点击这里你可以链接到www.google.com ###只是显示百度的图片 ###只是显示图片，这里用的是相对路径 显示图片也可以用原生的html标签 ###想点击某个图片进入一个网页,比如我想点击github的icorn然后再进入www.github.com 文字被些字符包围 文字被些字符包围 只要再文字前面加上&gt;空格即可 如果你要换行的话,新起一行,输入&gt;空格即可,后面不接文字但&gt; 只能放在行首才有效 文字被些字符包围,多重包围 文字被些字符包围开始 只要再文字前面加上&gt;空格即可 如果你要换行的话,新起一行,输入&gt;空格即可,后面不接文字 但&gt; 只能放在行首才有效 部分文字的高亮如果你想使一段话部分文字高亮显示，来起到突出强调的作用，那么可以把它用``包围起来。注意这不是单引号，而是Tab键和数字1键左边的按键（注意使用英文输入法）。 example： ThankYou. Please Call Me Coder 代码片段高亮显示GitHub的markdown语法还支持部分语言的代码片段高亮显示。只需要在代码的上一行和下一行用```标记。1public static void main(String[] args)&#123;&#125; //Java 1int main(int argc,char *argv[]) //C 1document.getElementById("myH1").innerHTML="Welcome to my Homepage";//javascript 1string &amp;operator+(const string&amp; A,const string&amp; B) //cpp list列表条目使用写文章时经常会用到list列表条目。GitHub的markdown语法里也支持使用圆点符。编辑的时候使用的是星号*。 国籍：中国 城市：北京 大学：XX大学注意：星号*后面要有一个空格。否则显示为普通星号。GitHub还支持多级别的list列表条目： 编程语言 脚本语言 Python 特殊字符处理有一些特殊字符如&lt;,#等,只要在特殊字符前面加上转义字符\即可你想换行的话其实可以直接用html标签\ 插入表格在Markdown中插入表格比较麻烦，需要Markdown的扩展语法，但是插入HTML就没有那么麻烦了，因此我们可以通过曲线救国的方式来插入表格。在Markdown中，&amp;符号和&lt;会自动转换成HTML。 &lt;div&gt; &lt;table border=&quot;0&quot;&gt; &lt;tr&gt; &lt;th&gt;one&lt;/th&gt; &lt;th&gt;two&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Hello&lt;/td&gt; &lt;td&gt;你好&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt; one two Hello 你好]]></content>
      <categories>
        <category>Geek</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[BZOJ题目一句话题解整理]]></title>
    <url>%2FNOIPskills%2FBZOJ%E9%A2%98%E7%9B%AE%E4%B8%80%E5%8F%A5%E8%AF%9D%E9%A2%98%E8%A7%A3%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[BZOJ题目一句话题解整理就当是复习一下自己做过的题,顺便提供一个简要题解给大家看.做题时候实在想不出来看一下一句话题解,可以有一个提示的作用又不至于一下子知道了全部浪费了一道题吧..部分题目(如我A过得大部分奶牛题)是别人拿我的账号做的,不提供题解.可能会漏掉很多做过的题..因为可能点页数不小心点错了什么的UPD.本来想把那些没写过但是知道题解的也写了..但是写完这些已经累死了QAQ 已AC的题目及部分未AC但是知道标算的题目(数学题均不提供分析过程,公式):1000:A+B1001:平面图最小割,转对偶图最短路1002:矩阵树定理,也可以通过推矩阵的递推关系得到递推式1003:最短路+DP1007:半平面交1008:组合数学,需要高精1010:斜率优化/四边形不等式推决策单调性1012:线段树1014:Splay维护字符串的Hash值1016:矩阵树定理,相同权值压联通块,对一个联通块用一次矩阵树定理计算方案数,累积答案 也可以DFS1023:仙人掌DP找直径1031:直接构建出倍长后串的SA,用rank数组做1034:贪心1036:树链剖分/LCT1038:半平面交1041:数论,推一下公式 也可以用一种跟勾股定理相关的做法1043:计算几何,细节已忘.1050:并查集,细节已忘.1053:爆搜1054:模拟1059:二分图最大匹配,对行和列做点1061:不等关系转费用流建图1066:最大流1067:线段树分类讨论1070:费用流1072:状压DP,据说暴力可过1083:最小生成树1087:状压DP1088:枚举状态,暴力1089:找规律,需要高精,也可以用组合数学推一下1092:模拟1095:动态树分治,或者dfs序线段树维护括号序列1099:线段树+分类讨论1101:莫比乌斯反演,同HAOI ProblemB1103:dfs序,或者链剖1106:树状数组.考虑记录下每个元素上一次出现的位置,然后BIT搞一搞.1112:权值平衡树,中位数相关.1113:好像是单调栈扫一扫就没了.1121:一个结论题,答案是n/2.1131:树形DP一下.1132:答案的式子可以看出一个坐标的前缀和,优化一下暴力.1143:利用那些图论定理,最长反链=n-最大匹配.1145:很多种情况,BIT维护一下然后把这些情况加加减减.网上有WJMZBMR题解.1146:一个比较模板的题..为了不被卡常卡空间可以考虑把其中一维搞上整体二分.1167:空数据,Python 2B1176:cdq分治,或者kdtree1180:LCT1191:二分图最大匹配1192:考虑二进制分解.1193:大规模贪心,小规模暴力.1195:状压DP,与某道TC SRM一样.1202:加权并查集,维护前缀和.1208:权值平衡树.1213:二分,Python.1214:空数据,Python 2B1227:组合,容斥,二维BIT.建议看黄学长题解.1269:区间Splay裸题.1307:题意是找最大的一个区间使得区间内为一个排列.记录前驱后继,可以得到符合条件的判定关系与区间长度,区间最大值最小值差有关.通过前驱后继来查询这个东西.1318:同13071336:最小圆覆盖1337:同13361342:对当前区间搞了个set.1345:规律+结论题,附核心代码,我也不知道怎么证的 for (int i=1;i&lt;=n;i++) { in(a[i]); if (i&gt;=2) { if (a[i]&gt;maxn) sum+=a[i]; else sum+=maxn; } maxn=a[i]; } cout&lt;&lt;sum&lt;&lt;endl; 1351:空数据,Python 2B1360:空数据,Python 2B1370:并查集.(这不是某NOIP题吗1379:答案就是m.忘了为什么了.1398:KMP最小表示,卡SAM内存.1406:数论,找质因子搞一搞.1419:DP一下.枚举选到了i张红的,然后1~b枚举选到了多少黑的.似乎需要滚一下数组压内存.1453:方法很多,提供四个.1.LCT维护删除时间最大生成树 2.cdq分治+并查集 3.A*爆搜 4.线段树维护连通性1482:空数据,Python 2B1492:斜率优化,因为状态点的x不单调,所以需要平衡树或者cdq分治1500:区间Splay.1502:Simpson积分.1503:权值平衡树1513:二维线段树1529:答案是联通块个数,并查集或者Tarjan都可以.1532:二分答案,最大流判定.1543:同JSOI2008最小生成树计数.1563:四边形不等式推出决策单调,二分决策点.1568:李超线段树.1588:权值平衡树.1798:线段树双标记.但是我是拿LCT写的.1800:暴力1821:二分答案+并查集1853:爆搜1857:三分套三分.1875:矩乘优化DP1876:Python题,直接GCD1877:拆点费用流1878:离线处理+树状数组1879:状压DP1880:四遍最短路,然后DP一下1898:可以发现每12次还是6次一个循环,然后对大范围矩乘一下,剩下的一点暴力DP出来.1902:考虑p进制拆分,答案是拆分后每一位+1的乘积 证明好像是考虑Lucas定理的也可以数位DP+组合数学,但是无论哪种做法都需要Python高精度1907:树的最小路径覆盖,可以直接树DP/贪心1922:分层图最短路1923:高斯消元.1924:强联通分量缩点最长路1925:DP.需要用到一些抖动子序列的性质.1941:kdtree最远点1951:数论板子合集.1968:枚举1~n统计n/i的和1969:LCT维护两点间桥边数量,不知道当年标算是什么但应该不是LCT吧1979:二分答案,用平衡树判定.1984:链剖/LCT裸题.1997:平面图判定.需要平面图理论.2000:可以贪心的博弈问题.网上很多证明.2001:可以LCT,也可以cdq,cdq的话需要很多最小生成树的性质.2002:可以LCT,可以分块.2003:特技爆搜.2004:矩乘优化DP2005:莫比乌斯反演2006:线段树+堆维护五元组2012:容斥+组合,同SDOI2013Spring2013:DP+二分2045:同POI2007Zap2049:国内第一个LCT2051:点分治2054:并查集的特技2056:嘿嘿嘿2064:状压DP2089:同2090.2090:权值线段树优化一下DP.感觉这个DP好像并不一定对啊..但是大家好像都是这么写的.2093:左右端点移动一下找到目标位置,然后倍增.2096:单调队列搞一搞2111:组合数搞一搞,需要Lucas2117:同20512141:cdq分治2151:堆+贪心2154:莫比乌斯反演,有很多种公式化法,我的好像是比较傻逼的那种..2157:LCT,随便打标记2163:直接最小割过了,其实应该转对偶图然后最短路才对.2186:考察线性的逆元求法.2190:反演分析一下,最后却发现答案是个跟phi有关的表达式..2213:DP乱搞一下.附核心代码 for (int i=2;i&lt;=n;++i) ch[i]=getchar(),maxn=max(maxn,ch[i]-‘a’); for (int i=1;i&lt;=n;++i) { int y=ch[i]-‘a’; for (int j=0;j&lt;=maxn;++j) { ++f[j][y];–f[y][j]; if (!g[y][j]) g[y][j]=1; else if (g[y][j]==2) –g[y][j],++f[y][j]; if (f[y][j]&lt;0) f[y][j]=-1,g[y][j]=2; if (g[y][j]) ans=max(ans,f[y][j]); if (g[j][y]) ans=max(ans,f[j][y]); } }2216:显然权函数单调,满足四边形不等式,决策单调.2222:似乎数据有问题还是什么?面向数据了一波.2223:主席树2229:GHTree2241:暴力枚举答案然后检测,检测时候需要特技,感觉理论复杂度并不对但是过了2243:链剖或者LCT,我写的链剖2244:cdq分治做三维偏序的DP,答案实际上可能非常大会爆…但是出题人十分懒惰没管那样的数据,所以double就过了2275:考虑斐波那契分解.有一个定理,然而并不会证明.2280:倍增+最小圆覆盖,卡评测好题.2288:线段树优化费用流,模拟费用的取反什么的.5倍经验.2295:乱搞.附核心代码 char ch[MAXN],tmp[20]={‘l’,’u’,’v’,’l’,’e’,’t’,’t’,’e’,’r’};int main(){ for (scanf(“%d”,&amp;T),getchar();T;T–) { gets(ch+1);n=strlen(ch+1);ans=0; for (int i=1,j=0;i&lt;=n;i++) { j+=(ch[i]==tmp[j]); if (j&gt;=9) j=0,ans++; } printf(“%d\n”,ans); }}2296:找到一个P=987654321*10^6,答案就是(P+n)-(P+n)mod n2299:裴蜀定理2300:平衡树维护凸包.因为求的是凸包周长,所以贡献不可累积,故不能分治.2301:莫比乌斯反演.同POI2007Zap2326:矩乘.2336:模拟退火2344:暴力找三元环.2351:Hash2377:同POI2012 A Horrible Poem2378:PA2011Kangaroo kdtree 把序列[L,R]看成点(L,R) 然后查询的就是右下角的矩阵,打一些标记搞一搞.2393:同SCOI2010幸运数字2395:二维最小乘积生成树,裸.2428:模拟退火2433:计算几何.2434:AC自动机+线段树.2438:强连通分量.2440:莫比乌斯函数的应用,实际上就是容斥.2448:区间DP,线段树优化,卡普通线段树常数,需要zkw线段树.2456:卡内存..乱搞2458:分治,分治子结构内暴力+剪枝2460:线性基2461:乱DP一波2462:同2351Hash2463:根奇偶有关的博弈,一眼看出规律,证明可以考虑转化成骨牌铺满格子的问题.2464:裸最短路2467:矩阵树定理2506:小范围直接记录答案,大范围暴力.2514:同HNOI2010那个.2527:整体二分.2555: LCT维护SAM Parent树Right集合2568:按位考虑的乱搞树状数组,大量逻辑混乱…2588:找dfs序,树上建个主席树2594:LCT2595:斯坦纳树.2600:贪心,找规律,中位数相关2618:半平面交2623:RGB识别系统的弱化.湖南当年请的教授出题真厉害..2626:kdtree+堆2631:LCT+双标记2639:二维莫队.2642:可以发现一次删一段连续的一定是最优的,所以二分一下删的长度,半平面交2648:kdtree2654:二分答案然后最小生成树2656:Python题2657:实际上就是让你找直径,没有三角剖分的姿势也没事2659:直觉型数学题2660:DP一下.2661:费用流2662:分层图最短路2671:类似莫比乌斯反演,推一推式子就行了2683:我写的cdq2697:贪心2705:莫比乌斯反演2716:cdq分治2717:奇怪的姿势枚举一发 for (int i=1;i&lt;=(n&gt;&gt;1);i++) for (int j=0;j&lt;n;j++) printf(“%d %d %d\n”,j+1,(j+i)%n+1,(j+i+i)%n+1);112718:同CTSC2008祭祀2721:随便化一下式子2724:分块2729:组合数,需要Python2732:二分答案半平面交判定2733:平衡树启发式合并.2738:整体二分,也可分块2739:四边形不等式,然后发现决策单调,然后分治找决策点2741:分块套可持久化trie2751:根据题目找一个性质啥的..细节已忘2753:本意是求最小树形图,实际上因为题目特殊所以可以BFS一遍然后做最小生成树2754:AC自动机fail树+容斥,实际上暴力也过了.2759:题目给的是个环套树,对LCT维护一个额外的father,然后扩欧求答案2761:妈的智障..2763:分层图最短路2783:dfs时候维护一下set2786:DP一下,需要Python2789:还是考虑上个位置,然后树状数组乱搞一下2795:hash,对一段数枚举约数然后判定2796:记忆化搜索2809:权值平衡树启发式合并,或者左偏树2812:空数据,Python 2B2813:斐波那契数性质的应用,线筛时候记录一下质因子,约数个数之类的2814:人生写过最码农的题,可以LCT可以链剖,只不过都得维护30来个量2815:支配树弱化版,倍增2816:LCT2818:同SDOI2012Longge的问题2822:卡特兰数相关,需要Python2823:最小圆覆盖2824:好像是个A*,我面向数据了一波2843:LCT2850:kdtree2851:灭绝树.2862:二分limit,dp2864:计算几何+最大流2875:矩乘2883:树套树,线段树套平衡树,但是我写的是线段树套权值线段树2886:显然先从整个矩形的边界上走比较好,可以发现转一下就是杨辉三角,再然后就没别的了2888:LCT维护树的重心,需要启发式合并2890:同POI2012 A Horrible Poem2896:同AHOI2005航线那题2901:可以发现能用前缀和做..2908:考虑建32位的信息维护,链剖或者LCT2916:暴力2936:灌水法,堆+爆搜2937:写了个n^2暴力就能过2946:SAM时刻记录匹配上的最大值2957:线段树维护一段区间斜率2961:圆的反演,然后就成了cdq分治做半平面交2976:模拟一下得到一堆同余方程,扩欧找最小解2986:把2440反过来,做法一样2987:类欧裸题,然而还是不是很理解类欧3038:记录区间最大值,如果还能开根,暴力下放,最多开根lglg次3040:平板电视+Dij3043:乱搞一发,附核心代码 in(n);for (int i=1;i&lt;=n;++i) in(a[i]); for (int i=n;i;--i) a[i]-=a[i-1],ans1+=(i&gt;1)*a[i]*(a[i]&gt;0),ans2+=(i&gt;1)*(-a[i])*(a[i]&lt;0); cout&lt;&lt;max(ans1,ans2)&lt;&lt;endl&lt;&lt;abs(ans1-ans2)+1&lt;&lt;endl; 1231233051:平面图求域+点定位.3052:莫队上树.3053:高维kdtree3064:线段树+标记+时间戳.3069:LCT维护是否存在桥边,实际上可以并查集3070:考虑固定指数,把底数慢慢往上调,比较难写,于是我当时面向数据了一发3072:神DP.建议看Claris题解.3073:线段树优化建图最短路3084:扩展KMP.建议看Claris题解3098:生日攻击.3100:根前面那个什么 玩具 是一样的.3103:跑一边马拉车,然后并查集缩点一下,就成了弦图染色问题.3110:整体二分3117:链表+堆搞了一下,看似不科学实际上飞快3130:显然费用的分配是可以贪心的.然后二分.3132:二维树状数组3153:TopTree/ETT+LCT 然而出题人的做法不是这两个…3155:树状数组乱搞一下3170:链剖3172:建出多串后缀自动机,直接搞3176:显然要考虑逆序对什么的,然后还需要树状数组,附核心代码 for (int i=1,last;i&lt;=n;i=last+1) { for (last=i+1;a[last-1]&gt;a[last]&amp;&amp;last&lt;=n;last++);last–; for (ans++,l=i,r=last;l&lt;r;swap(a[l++],a[r–])); } for (int i=n;i;i–) ans+=query(a[i]),add(a[i]); cout&lt;&lt;ans&lt;&lt;endl;3178:循环构成了一个树形结构,然后就可以DP了3180:单调栈乱搞 需要SPJ 但是我好像恰巧跟std策略相同,直接A了3181:大质数暴力,小的二分乱搞一下3196:树套树3197:树Hash+乱搞3198:容斥+组合3199:显然图是个V图,半平面交弄出来,然后最短路3203:计算几何,答案在凸壳上,三分一下3209:数位DP+数论3211:同 上帝造题七分钟23223:区间Splay裸题.3224:权值平衡树3226:把区间拆成两倍来处理开闭问题,然后线段树就行了,可以看成区间加减01,区间覆盖01的问题3228:把整个坐标系旋转45°,然后就成了扫描线sb题,问题在于统计的不是面积而是格子…所以细节非常麻烦3229:满足四边形不等式然后DP就好了3231:矩乘3236:莫队/树套树/cdq分治.3237:我写的cdq分治,实际上也有别的做法3238:后缀自动机Parent树上DP一下3243:基于随机化的乱搞3251:注意到fib数没多少项就爆int了,所以暴力3252:dfs序,然后变成了rmq问题,写个线段树3260:同28863262:cdq分治维护三维偏序3267:同2288.3268:ST表搞一搞.source里都给写了题解了..3272:同32673277:SAM基本应用3282:LCT3283:BSGS.3295:cdq分治.注意每次修改会产生更多额外的贡献要单独减去的3309:莫比乌斯反演3323:序列平衡树维护多项式3329:把两问分别考虑,一个数位DP一个矩乘3339:跟SDOI2008HH的项链方法差不多,也是离线然后考虑找到前驱后继线段树做3350:同31033417:对一个环可以重复走多次每次长度都是+2的,所以第一次BFS看看路径长奇偶就行了.3424:跟dfs序有关.有波兰人论文.3439:建trie,对trie dfs一遍,同时建立主席树3463:分块维护凸壳3473:同32773482:SPFA预处理含x条边的情况然后做.建议看Claris题解.3483:建trie,可以发现询问能跟trie的dfs序对应起来,所以再建一棵主席树.3489:我写的3d kdtree3493:同HNOI2010那个3495:考虑2-SAT建图.安利Claris题解.3498:枚举三元环,我拿度数倍数判的实际上应该是根号度数..3500:OEIS有数列3501:把3501加点数论特技,CRT什么的..3502:同32723505:组合数一下3514:LCT.记录下某条边被加入成环,主席树统计答案.3522:树DP.可以O(n)特技.3524:主席树3527:FFT3529:莫比乌斯反演+树状数组3530:AC自动机+数位DP3531:动态开点的LCT/链剖线段树3532:退流科技.3533:线段树维护凸包3534:构建一个合理的矩阵然后矩阵树定理,这个矩阵的构建需要十分高超的概率姿势,建议看高大哥的题解3543:有定理好像是这样的正方形不超过根号个还是什么来着..忘掉了.反正是结论题3544:搞个set就好了3545:本题不强制在线,标算为平衡树启发式合并3551:对3545强制在线后,我们需要主席树+倍增搞一发3555:hash3566:树形概率DP3571:最小乘积生成树+KM.3572:虚树.3573:考虑对树DFS,做一个对数的转化3575:不靠谱的暴力做法..加上堆维护一下3585:又是考虑离线记前驱后继然后线段树的题3589:实际上是虚树.用链剖线段树随便打了打标记.然而标算应该是LCT做链的并吧.3594:线段树优化DP3603:分块高斯消元.3605:分治FFT.3606:平面图求域+点定位.3607:最长路剖分一下,再轻重路剖分一下,安利Claris题解.3613:贪心/找规律.3616:kdtree+bitset3622:厉害的组合数+DP.3629:有一个什么分解定理来着…3638:同35023643:爆搜3647:hash一下,好像也是个双倍经验3651:对ZJOI2012网络去掉权值的维护3658:单调栈+树状数组3659:矩阵树定理+BestTheorem3667:MillerRabin+PollarRho3668:按位贪心3669:LCT3672:点分治+斜率优化+cdq分治.3673/3674:rope的应用.3675:满足四边形不等式,有决策单调3676:PAM裸题,但是我写的SAM+manacher3680:模拟退火/多重爬山3585:VEB树.3687:bitset应用3688:线段树优化DP3709:贪心.肯定先打能回血的.3710:构造神题.波兰人有论文.3711:分治优化DP,分治过程中用线段树找决策点,决策点单调.3712:树上倍增.3713:暴力拆分.3714:前缀和Prim.3715:找找最大边界值,随便判定一下..3716:最小割转最大流,然后贪心,需要一定坐标变换.3717:高姿势的状压DP.3718:只要能卡住就行了,树状数组.3719:线段树套个vector扫描线扫一扫.3721:随便贪心,考虑奇换偶偶换奇.3722:树形DP.3725:扫一遍,扫的时候记录出现位置,更新答案.3726:悬线法.3727:稍微推一推公式,然后就发现代价可以根据size什么的树形DP了.3728:堆贪心.3732:跟某NOIP货车运输一样.3733:爆搜+信仰剪枝.安利潇爷(Time-Machine)题解3735:堆搞一搞3737:跟phi的反函数一个做法.3743:显然可以直接树形DP.3745:分治,前缀和,单调栈.3754:很好的乱搞题.可以考虑看成是一堆点,然后中间有一条水平直线算代价.3767:Python题.3779:LCT+dfs序线段树3791:可以比较容易的DP出来.3802:预处理转移的DP.也可以直接手动分类讨论出来,只要你不嫌手累代码长难调.3810:记忆化搜索3811:这个期望和概率题好神啊..建议直接上网看题解3812:状压DP,需要一些奇怪姿势.3815:kdtree.3816:空数据 Python 2B3817:类欧题,类欧前需要很多变形.3831:挺sb的一个DP.3834:莫比乌斯反演.3837:线筛处理一些东西,然后DP.3838:看成线段树维护括号序列,然后就发现需要维护的东西特别多还不止一棵线段树.3839:考虑从某个点开始向四个方向扩展的凸包,预处理,然后对询问用线段树扫描线一下.3884:高姿势的数论题.3895:dfs,过程中需要很多情况的讨论,建议看Po姐题解.3915:矩形剖分.3916:枚举删除的位置,Hash.3917:考虑爆搜各种剪枝,每次范围都是之前的十分之一.3922:搞一堆线段树分别对应不同公差,大公差暴力,小的线段树.3926:trie上SAM扩展裸题.因为度数少,所以暴力合并.3928:区间DP一下.3944:杜教筛裸题.3950:同3607.3984:按时间分治,维护删除时间最大的基.3990:操作序列的顺序并不影响答案,根据这个性质所以搜.3991:虚树.3993:二分费用最大流判定.3994:比较厉害的莫比乌斯反演,需要一个性质.安利高大哥题解.3995:线段树维护两排点,分类讨论.3998:SAM的应用.4001:找规律.实际上要靠生成函数来推..4010:拓扑.4020:手写编译器.4025:LCT,或者cdq分治.4027:贪心.4029:模拟.4031:矩阵树定理.4032:前两问直接DP,后两问SAM上DP.4033:看似n^3,实际上n^2的树DP.4034:链剖,4036:子集和变换.4043:同3802.4048:同3928.4052:发现gcd最多有log个,单调栈一下.4057:状压DP.4059:奇怪的暴力.4062:同3658.4063:智障啊..4066:卡掉离线算法差评不已.kdtree4068:维护套着堆的线段树就行了,每次考虑用后来的任务替换一下前面的任务.4084:Hash4085:线段树维护矩乘.据说考场卡常?矩阵可以从33优化到22.4086:组合数容斥.4088:大模拟.4106:WF签到题.4127:数一直加的,已经没有负数的就不用管了,其他的可以暴力下放.4128:矩阵BSGS,矩阵求逆或者不求逆的BSGS.4130:kdtree.上面写过这个题了..4140:因为强制在线了,所以要二进制分组4143:乱搞,暴力,没技术含量.4144:最短路+最小生成树.4145:状压DP.4146:写个计数器.sb题4147:又一个根据很多情况来讨论的博弈.看Claris题解把4148:构造.算基础构造题了.4149:考虑单调栈搞一搞.4151:一个非常厉害的.最短路?安利Claris题解4152:把点排个序,构个图,最短路.4154:可以kdtree,要是不只是子树的话,点分就好了.4160:这题好神啊.安利Claris题解.4180:构建出SAM,然后可以矩乘4184:按时间分治线段树维护一下线性基4194:k做一下前缀和就可以看成是凸壳,然后二分一下斜率什么的.4195:并查集4196:链剖4198:Huffman树+贪心4199:SAM Parent树上DP4209:把PA的Bazarek用主席树来做动态的4212:同3483,但是卡trie转移边内存.4216:分块,也卡内存.4229:同PA2011HardChoice4236:随便统计一下三个字母数目更新下答案就行了.4245:按位贪心4247:背包变形4250,4251前面都出现过了4253:把AHOI那个密码箱找质因子的过程来弄成PollardRho4260:trie正着一遍倒着一遍DP,但是我写的可持久化trie,差点T飞4262:考虑询问离线,然后用线段树搞一搞,安利Claris题解.4263:某TCSRM题改编,结论题,贪心一下.4264:边集Hash.4266:同 一个动态树好题4269:线性基4288:跟Baltic2014sequence一样4289:转一下建图,差分建图,,然后最短路4291:跟Bazarek一样4292:按位暴力4293:大小关系是始终不变的,所以排序后可以在线段树上二分.4294:斐波那契数列模10^m有循环节,利用这个,然后搜4296:好像是考虑贪心的删?忘了..4297:神题.安利Claris题解.4298:比较厉害的边集Hash.4299:主席树.可以发现那个东西的一个性质.这个性质如果说出来就没意思了..4300:builtin大法好啊..4305:组合+容斥4310:二分+后缀数组判定/hash判定4311:按时间分治的线段树,答案在凸壳三分4312:大型分类讨论4316:仙人掌DP4317:同20514318:同Easy那题4319:简单的构造4320:小范围记录答案,大范围暴力 的那种题目4327:SAM直接跑4337:树Hash4347:比较厉害的DP.安利Claris题解.4352:又是个双倍经验..同 A Huge Tower4358:考虑kdtree,序列[L,R]当成(L,R)这样子4364:线段树乱搞..乱更新一下4367:搞出暴力DP之后,满足四边形不等式,所以决策单调,然后分治优化,主席树找决策4373:对区间是否符合条件有一个有关gcd的判定,然后线段树就行了.也可以Hash区间和,区间平方和,立方和.4378:特技差分然后树状数组.4380:区间DP.4401:枚举约数.4403:组合数学.4404:按位搜.4407:莫比乌斯反演4408:同FRBSUM4414:利用一点斐波那契数列的性质做,可以找规律.4415:线段树模拟4418:线段树.4419:暴力4421:智障..4423:考虑对偶图中两点连通性与原图中两点连通性关系,然后并查集维护对偶图的连通性.4424:nlogn可以差分树剖或者LCT,O(n)就利用一些特技乱搞一下.4425:搞个堆4426:满足四边形不等式,分治优化下DP4427:计算几何+二分图判定4428:一点特殊的记忆化搜索姿势然后杜教筛4429:二分图最大匹配4430:树状数组找一下逆序对什么的4432:链表大模拟4434:坐标范围很小,考虑分成一小段一小段然后做4435:割流转化,然后最小割树4437:BFS预处理,然后对每个询问三分4438:忘掉了QAQ4439:最小割4444:DP了一下.好像是n倍经验4452:离线,并查集4453:高端的姿势!请单独看我题解4454:O(1)gcd黑科技4455:一点状压4456:分治+Dij4458:超级钢琴上树4465:第二类strling数变形4471:矩乘+贪心模拟4472:树形DP一下4475:找规律4488:同cerc2013 Magical Gcd4490:同44714500:差分约束4503:FFT4505:考虑只找那个字符串的一半,暴力枚举星号状态,然后匹配4513:数位DP4514:费用流一直跑,跑到变负数4515:李超线段树4516:SAM裸题4517:直接错排,但是建议写容斥4518:斜率优化,实际上也可以直接四边形不等式然后分治4519:GHtree4520:kdtree,姿势同jzpfar4521:数位DP一下4522:按他的要求做就行了..写Pollardrho,然后扩欧什么的..4523:可持久化trie,时刻维护单调栈匹配的最大长度4524:打表+堆然后搜的..4527:这题好神..但是也属于那种单调栈+线段树搞一搞的题目.安利Claris题解4538:链剖线段树+kdtree4540:同42624543:提供nlogn 点分治 O(n) 利用启发式思想的树形DP4544:打表观察找到一个积性函数.4545:SAM强行上trie..实际上还是25554548:同40624551:并查集4552:二分答案,线段树4553:发现成立条件跟a[i],minb[i],maxb[i]有关.实际上是个三维偏序,可以kdtree可以cdq分治.4554:拆点,二分图最大匹配4556:SAM+dfs序+主席树4557:树形DP一下4558:容斥.需要很多细节讨论4562:拓扑4263:直接上错排4565:状压DP.4566:建两个SAM,考虑下合并代价什么的就行了4568:点分治/倍增+线性基(Claris的点分治模板就是快)4569:ST表+并查集4598:可以考虑nlogn的点分治,这是doc老师给的标算,同时还有一种O(n)的做法.基于以前的暴力LCA的DP,考虑使用上启发式思想,可以做出一个漂亮的O(n)DP,基本同 4543Hotel加强版 这个题一样.4599:首先可以看出回文串的贡献都是可以单独考虑的,然后其他的串可以考虑行列拆点最小割.具体建图已忘.4600:考虑按C分类,然后状压DP.4601:比较重要的两个性质:1.路径只有两种可能,分别是两种绕法,因为我没法贴图片,所以留给大家自行思考.想到这两种绕法之后,还有一个性质,就是选出一行/列,考虑这一行/列的插头状况,发现只有一个插头是非空的(当然这并不意味着要让你写一个插头DP,只是这个性质是比较有用的.有了这两个性质就可以独立考虑做法了.4602:带权并查集,或者直接dfs(因为无向图DFS树只有返祖边没有横向边).为了解决分数特别大的问题,考虑记录质因子或者取log(会被卡精度).4603:正四面体剖分,然后搞一搞.]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高精度]]></title>
    <url>%2F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F%E9%AB%98%E7%B2%BE%E5%BA%A6%E8%AE%A1%E7%AE%97%2F</url>
    <content type="text"><![CDATA[一、定义高精度计算是一种程序设计的算法。由于中央处理器的字长限制，如32位CPU中一个整数最大只能取值4,294,967,295。因此在进行更大范围的数值计算中，往往要采取模拟手段。通常通过分离字符的方法通过数字数组进行输入。通过数组倒序输出。通过模拟竖式计算进行计算。一般而言，主要模拟的是按位运算，但可以通过在一个数组元素中存储多位数的方法来优化时间复杂度。 加法add 1nothing 减法sub2017.5.28 sub1 提供了500位a-b的解决方案1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;string&gt;using namespace std;int a[550], b[550], c[550];string s1, s2;int main()&#123; cin&gt;&gt;s1&gt;&gt;s2; int len1 = s1.size(), len2 = s2.size(), ok = 1; if(len1&lt;len2 || s1&lt;s2)&#123; swap(s1, s1); swap(len1, len2); ok = -1; &#125; for(int i = 0; i &lt; len1; i++)a[len1-i] = s1[i]-'0'; for(int i = 0; i &lt; len2; i++)a[len2-i] = s2[i]-'0'; int i = 1; while(i&lt;=len1 || i&lt;=len2)&#123; if(a[i] &lt; b[i])&#123; a[i] += 10; a[i+1]--; &#125; c[i] = a[i]-b[i]; i++; &#125; while(c[i]==0 &amp;&amp; i&gt;1)i--; for( ; i &gt;= 1; i--) cout&lt;&lt;c[i]; return 0;&#125; 乘法sum 1nothing 除法div 1nothing 结构封装all2017.5.28 all1 支持+,-,*,==,!=,&lt;,&lt;&lt;,&gt;&gt;,300位?的操作(vector+string+模拟竖式+单位存储)2017.7.1 有时候会RE，待修改123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;string&gt;#include&lt;vector&gt;using namespace std;struct Bigint&#123; vector&lt;int&gt;s; int is_minus; Bigint(long long num = 0, int ok = 1)&#123; *this = num; is_minus = ok;&#125;//构造函数,元素初始值为0 Bigint operator = (long long num)&#123; s.clear(); do&#123; s.push_back(num%10); num /= 10; &#125;while(num &gt; 0); return *this; &#125; Bigint operator = (const string&amp; str)&#123; s.clear(); for(int i = str.size()-1; i &gt;= 0; i--) if(str[i] == '-')is_minus = -1; else s.push_back(str[i]-'0'); &#125; Bigint operator + (const Bigint&amp; b)const&#123; Bigint c; c.s.clear(); Bigint n = *this, m = b; if(n.is_minus==-1 &amp;&amp; m.is_minus==1)&#123; c = m-n; &#125;else if(n.is_minus==1 &amp;&amp; m.is_minus==-1)&#123; c = n-m; &#125;else &#123; if(n.is_minus==-1 &amp;&amp; m.is_minus==-1) c.is_minus = -1; int x = 0, len = max(n.s.size(),m.s.size());//x是进位 for(int i = 0; i &lt; len; i++)&#123; if(len &gt;= n.s.size())n.s.push_back(0);//不够长的话补0 if(len &gt;= m.s.size())m.s.push_back(0); c.s.push_back(n.s[i]+m.s[i]+x); x = c.s[i]/10; c.s[i] %= 10; &#125; if(x)c.s.push_back(x);//最高进位 len = c.s.size()-1; while(c.s[len]==0 &amp;&amp; len&gt;0)len--; c.s.resize(len+1); &#125; return c; &#125; Bigint operator - (const Bigint&amp; b)const&#123; Bigint n = *this, m = b; int ok = 1; //保证被减数大于减数 if(n.s.size()&lt;m.s.size() || n.s.size()==m.s.size()&amp;&amp;n.s&lt;m.s)&#123; swap(n.s, m.s); ok = -1; &#125; Bigint c; c.s.clear(); int len = max(n.s.size(), m.s.size()); n.s.resize(len); m.s.resize(len); c.s.resize(len);//改变大小自动补0防止内存错误 for(int i = 0; i &lt; len; i++)&#123; if(n.s[i] &lt; m.s[i])&#123; n.s[i] += 10; n.s[i+1]--; &#125; c.s[i] = n.s[i]-m.s[i]; &#125; len--;//最后一位的坐标 while(c.s[len]==0 &amp;&amp; len&gt;0)len--;//删去多余的0 c.s.resize(len+1); //c.s.back() *= ok; c.is_minus = ok; return c; &#125; Bigint operator * (const Bigint&amp; b)const&#123; Bigint n = *this, m = b; n.s.insert(n.s.begin(),0); m.s.insert(m.s.begin(), 0); Bigint c; c.s.clear(); if(n.is_minus==-1 &amp;&amp; m.is_minus==1)c.is_minus = -1; if(n.is_minus==1 &amp;&amp; m.is_minus==-1)c.is_minus = -1; c.s.resize(n.s.size()+m.s.size()); for(int i = 1; i &lt; n.s.size(); i++)&#123; int x = 0; //进位 for(int j = 1; j &lt; m.s.size(); j++)&#123; c.s[i+j-1] += n.s[i]*m.s[j] + x;//原数+当前乘积+上次乘机进位 x = c.s[i+j-1]/10; c.s[i+j-1] %= 10; &#125; c.s[i+m.s.size()-1] = x;//进位 &#125; c.s.erase(c.s.begin()); int len = c.s.size(); while(c.s[len]==0 &amp;&amp; len&gt;0) len--; //删除多余的0 c.s.resize(len+1); return c; &#125; Bigint operator / (const Bigint&amp; b)const&#123; Bigint n = *this, m = b; Bigint c; c.s.clear(); int len = n.s.size()+m.s.size()-1; for(int i = len-1; i &gt;= 0; i--)&#123; &#125; return c; &#125; Bigint operator % (const Bigint&amp; b)const&#123; Bigint c; c.s.clear(); return c; &#125; Bigint operator += (const Bigint&amp; b)&#123; *this = *this+b; &#125; Bigint operator -= (const Bigint&amp; b)&#123; return (*this-b); &#125; Bigint operator *= (const Bigint&amp; b)&#123; *this = *this*b; &#125; Bigint operator /= (const Bigint&amp; b)&#123; *this = *this/b; &#125; Bigint operator %= (const Bigint&amp; b)&#123; *this = *this%b; &#125; bool operator &lt; (const Bigint&amp; b)const&#123; if(is_minus != b.is_minus)return is_minus&lt;b.is_minus; if(s.size() != b.s.size())return s.size()&lt;b.s.size(); for(int i = s.size()-1; i &gt;= 0; i--) if(s[i] != b.s[i])return s[i]&lt;b.s[i]; return false; &#125; bool operator &gt; (const Bigint&amp; b)const&#123; if(is_minus != b.is_minus)return is_minus&gt;b.is_minus; if(s.size() != b.s.size())return s.size()&gt;b.s.size(); for(int i = s.size()-1; i &gt;= 0; i--) if(s[i] != b.s[i])return s[i]&gt;b.s[i]; return false; &#125; bool operator &lt;= (const Bigint&amp; b)const&#123; if(is_minus != b.is_minus)return is_minus&lt;b.is_minus; if(s.size() != b.s.size())return s.size()&lt;b.s.size(); for(int i = s.size()-1; i &gt;= 0; i--) if(s[i] != b.s[i])return s[i]&lt;b.s[i]; return true; &#125; bool operator &gt;= (const Bigint&amp; b)const&#123; if(is_minus != b.is_minus)return is_minus&gt;b.is_minus; if(s.size() != b.s.size())return s.size()&gt;b.s.size(); for(int i = s.size()-1; i &gt;= 0; i--) if(s[i] != b.s[i])return s[i]&gt;b.s[i]; return true; &#125; bool operator == (const Bigint&amp; b)const&#123; if(is_minus != b.is_minus)return false; if(s.size() != b.s.size())return false; for(int i = s.size()-1; i &gt;= 0; i--) if(s[i] != b.s[i])return false; return true; &#125; bool operator != (const Bigint&amp; b)const&#123; if(is_minus == b.is_minus)return false; if(s.size() != b.s.size())return true; for(int i = s.size()-1; i &gt;= 0; i--) if(s[i] == b.s[i])return true; return false; &#125;&#125;;istream&amp; operator &gt;&gt; (istream &amp;in, Bigint&amp; x)&#123; string s; if(in&gt;&gt;s) x = s; return in;&#125;ostream&amp; operator &lt;&lt; (ostream &amp;out, const Bigint&amp; x)&#123; if(x.is_minus == -1)out&lt;&lt;-1*x.s[x.s.size()-1]; else out&lt;&lt;x.s[x.s.size()-1]; for(int i = x.s.size()-2; i &gt;= 0; i--)out&lt;&lt;x.s[i]; return out;&#125;int main()&#123; Bigint a, b; cin&gt;&gt;a&gt;&gt;b; cout&lt;&lt; a/b; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>高精度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图上的最短路径]]></title>
    <url>%2F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F%E5%9B%BE%E4%B8%8A%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[一、例题(为形象理解,可无视)：废话：暑假，小哼准备去一些城市旅游。有些城市之间有公路，有些之间则没有，为了节省经费以及方便计划旅程，小哼希望在出发之前知道任意两个城市之间的最短路径。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950数据：//本例所有数据均针对有向无环图(DAG)//代码看不懂的同学可以画一画样例数据的图的说。4 81 2 21 3 61 4 42 3 33 1 73 4 14 1 54 3 12//ans: 0 2 5 46 91 2 11 3 122 3 92 4 33 5 54 3 44 5 134 6 155 6 4//ans:0 1 8 4 13 174 51 4 94 3 81 2 52 4 61 3 7//ans:0 5 7 95 52 3 21 2 -31 5 54 5 23 4 3//ans:0 -3 -1 2 45 71 2 21 5 102 3 32 5 73 4 44 5 55 3 6//ans:0 2 5 9 9 二、Floyd-Wallshall1讲道理 本题Code123456789101112131415161718192021#include&lt;iostream&gt;using namespace std;int n, m, e[110][110];const int inf = 0xffffff;int main()&#123; cin&gt;&gt;n&gt;&gt;m; for(int i = 0; i &lt; n; i++) for(int j = 0; j &lt; n; j++) e[i][j] = i==j ? 0 : inf; for(int i = 0; i &lt; m; i++)&#123; int a, b, c; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; e[a-1][b-1] = c; &#125; for(int k = 0; k &lt; n; k++) for(int i = 0; i &lt; n; i++) for(int j = 0; j &lt; n; j++) if(e[i][j] &gt; e[i][k]+e[k][j]) e[i][j] = e[i][k]+e[k][j]; for(int i = 0; i &lt; n; i++)cout&lt;&lt;e[0][i]&lt;&lt;" "; return 0;&#125; 三、dijkstra1讲道理 本题Code1234567891011121314151617181920212223242526#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int n, m, d[110], book[110];int e[110][110];const int inf = 0xfffff;int main()&#123; cin&gt;&gt;n&gt;&gt;m; for(int i = 0; i &lt; n; i++) for(int j = 0; j &lt; n; j++) e[i][j] = (i==j ? 0 : inf); for(int i = 0; i &lt; m; i++)&#123; int a, b, c; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; e[a-1][b-1] = c; &#125; book[0] = 1; for(int i = 0; i &lt; n; i++)d[i] = e[0][i]; for(int i = 0; i &lt; n; i++)&#123; int x, y = inf; for(int j = 0; j &lt; n; j++)if(!book[j] &amp;&amp; d[j]&lt;y)y = d[x=j]; book[x] = 1; for(int j = 0; j &lt; n; j++)d[j] = min(d[j], d[x]+e[x][j]); &#125; for(int i = 0; i &lt; n; i++)cout&lt;&lt;d[i]&lt;&lt;" "; return 0;&#125; 优化的说1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int n, m, d[110], book[110];int e[110][110];int u[110], v[110], w[110], first[110], next[110]; //优化1：用邻接表代替邻接矩阵const int inf = 0xfffff;int main()&#123; cin&gt;&gt;n&gt;&gt;m; for(int i = 0; i &lt; n; i++) for(int j = 0; j &lt; n; j++) e[i][j] = (i==j ? 0 : inf); for(int i = 1; i &lt;= n; i++)first[i] = -1; for(int i = 1; i &lt;= m; i++)&#123; cin&gt;&gt;u[i]&gt;&gt;v[i]&gt;&gt;w[i]; e[u[i]][v[i]] = w[i]; next[i] = first[u[i]]; first[u[i]] = i; &#125; book[0] = 1; for(int i = 2; i &lt;= n; i++)d[i] = inf; for(int i = 1; i &lt;= n; i++)&#123; int x, y = inf; int k = first[i]; while(k != -1)&#123; if(!book[u[k]] &amp;&amp; d[u[k]]&lt;y)y = w[x=u[k]]; k = next[k]; &#125; book[x] = 1; for(int j = 1; j &lt;= n; j++)&#123; int k = first[x], t = inf; while(k != -1)&#123; if(v[k]==j)&#123; t = w[k]; break;&#125; k = next[k]; &#125; if(d[j]&gt;d[x]+t) d[j] = d[x]+t; &#125; &#125; for(int i = 1; i &lt;= n; i++)cout&lt;&lt;d[i]&lt;&lt;" "; return 0;&#125; 优化的说21//优化2,3：向量存储+优先队列 四、bellman-ford1讲道理 本题Code123456789101112131415#include&lt;iostream&gt;using namespace std;int u[110], v[110], w[110], d[110];const int inf = 0xfffff;int main()&#123; int n, m; cin&gt;&gt;n&gt;&gt;m; for(int i = 1; i &lt;= m; i++)cin&gt;&gt;u[i]&gt;&gt;v[i]&gt;&gt;w[i]; for(int i = 2; i &lt;= n; i++)d[i] = inf; for(int k = 0; k &lt; n; k++)&#123; for(int i = 1; i &lt;= m; i++)if(d[v[i]]&gt;d[u[i]]+w[i]) d[v[i]] = d[u[i]]+w[i]; &#125; for(int i = 1; i &lt;= n; i++)cout&lt;&lt;d[i]&lt;&lt;" "; return 0;&#125; 优化的说1234567891011121314151617181920#include&lt;iostream&gt;using namespace std;int u[110], v[110], w[110], d[110];const int inf = 0xfffff;int main()&#123; int n, m; cin&gt;&gt;n&gt;&gt;m; for(int i = 1; i &lt;= m; i++)cin&gt;&gt;u[i]&gt;&gt;v[i]&gt;&gt;w[i]; for(int i = 2; i &lt;= n; i++)d[i] = inf; for(int k = 0; k &lt; n; k++)&#123; int check = 1; //优化1：本次没有松弛操作，已经得到了最短路 for(int i = 1; i &lt;= m; i++)if(d[v[i]]&gt;d[u[i]]+w[i]) &#123; d[v[i]] = d[u[i]]+w[i]; check = 0;&#125; if(check)break; &#125; for(int i = 1; i &lt;= n; i++)cout&lt;&lt;d[i]&lt;&lt;" "; int flag = 0;//功能1：检测负权回路 for(int i = 1; i &lt;= m; i++)if(d[v[i]]&gt;d[u[i]]+w[i])flag = 1; if(flag)cout&lt;&lt;"flag was here \n and this graph has the ---\n"; return 0;&#125; 五、bellman-ford1讲道理的说 本题code12 六、习题集12]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>图论</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最小生成树]]></title>
    <url>%2F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%2F</url>
    <content type="text"><![CDATA[一、讲道理12 二、Kruscal codevs10781234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;using namespace std;int n, a[110][110], fa[110], co, ans;struct side&#123; int u, v, w; side (int u, int v, int w):u(u),v(v),w(w)&#123;&#125; bool operator &lt; (const side b)const&#123; return w&lt;b.w;&#125;&#125;;vector&lt;side&gt;e;int find(int x)&#123; return x==fa[x]? x : fa[x]=find(fa[x]);&#125;int main()&#123; cin&gt;&gt;n; for(int i = 1; i &lt;= n; i++)&#123; for(int j = 1; j &lt;= n; j++)&#123; int x; cin&gt;&gt;x; if(i &gt;= j)continue; e.push_back(side(i, j, x)); &#125; &#125; sort(e.begin(), e.end()); for(int i = 1; i &lt;= n; i++)fa[i] = i; for(int i = 0; i &lt; e.size(); i++)&#123; if(find(e[i].u) != find(e[i].v))&#123; ans += e[i].w; fa[find(e[i].u)] = find(e[i].v); &#125; &#125; cout&lt;&lt;ans; return 0;&#125; Codevs12311234567891011121314151617181920212223242526272829#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;int fa[100000];int find(int x)&#123; return fa[x]==x ? x : fa[x]=find(fa[x]);&#125;struct L&#123; long long u, v, w; &#125;e[100000];bool operator &lt; (const L A, const L B)&#123; return A.w&lt;B.w;&#125;int main()&#123; int n, m, count = 0; long long ans = 0; scanf("%d%d", &amp;n, &amp;m); for(int i = 0; i &lt; m; i++) scanf("%d%d%d",&amp;e[i].u,&amp;e[i].v,&amp;e[i].w); sort(e,e+m); for(int i = 0; i &lt;= n; i++) fa[i] = i; for(int i = 0; i &lt;= m; i++)&#123; if(find(e[i].u) != find(e[i].v))&#123; fa[find(e[i].u)] = e[i].v; ans += e[i].w; count++; &#125; if(count == n-1)break; &#125; printf("%lld\n", ans); return 0;&#125; 三、Prim12]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>图论</tag>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搜索]]></title>
    <url>%2F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F%E6%90%9C%E7%B4%A2%2F</url>
    <content type="text"><![CDATA[一、定义123456781.从数据集合中找出目标元素进行处理。2.当我们难以通过分析解决给定问题,或者找不到一个能有效解决问题的算法时,就不得不依靠反复的试错来寻求问题的答案了。 而且在这里,可以用启发式搜索,即利用问题拥有的启发信息来引导搜索,达到减少搜索范围、降低问题复杂度的目的。``` &gt;二、对象 ```c++1.目的: 可以是需要进行处理的目标元素, 或者是答案本身。2.类型: 可以是一个数值, 也可以是一个组合, 甚至可能可以是一个集合 三、数值1234类型: 线性, 二分, 散列 1.线性:从数组开头依次访问各元素,检查该元素是否与目标值相等。 线性搜索算法效率很低, 但是适用于任何形式的数据。2.二分:通过不断不断缩小解存在的范围, 从而求得问题最优解的方法。 效率较高，应用较广。3.散列:根据各元素的值来确定存储位置, 然后将位置保管在散列表中。 散列可以高效的执行动态插入，搜索，删除操作。 四、组合123451.穷竭搜索：将所有的可能性罗列出来，在其中寻找答案。2.迭代加深：对于可以用回溯求解但解答树的深度没有明显上限的题目。3.状态空间搜索：找到一个从初始状态到终止状态的路径。4.回溯法：将生成与检查有机的结合起来，实现剪枝。 5.A* IDA*：设计一个乐观的估价函数，实现剪枝。 五、练习题 2017.6.512尚未能包含大框架,详细见具体知识点。]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[碎碎念]]></title>
    <url>%2FDiary%2F%E7%A2%8E%E7%A2%8E%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[想要在这里，看到成长，和那些爱过的，应该是很美好的东西。 2015.8.261以帝之古念、决绝万世之殇、唯愿此生不再有泪、 2016.1.11一念起，天涯咫尺； 一念灭，咫尺天涯。 2016.1.2112记忆是掌心的水，不伦你摊开还是握紧，终究还是会从指缝中一滴一滴流淌干净。只是，那水的凉意。却是可以让人始终无法忘记。 2016.1.211那命运，生生相错不想见，世世轮回血色湮。 2016.2.41我在黑夜里。看着光明，我不渴望光明的到来，我只愿……成为那黑夜也都染不去的暗！ 2016.3.121我左手画圆，这便是天、我右手握拳，掌缘生灭、 2016.4.21心要静，气要清，不争名，不冒功。 2016.4.101234你今后的每一天，我都和你在一起。直到我不能。爱你。愿你在噩梦呓语时，身边会有人将你抱紧安慰。 2016.5.81樱花飞舞之时，愿你仍在我的身旁。 2016.5.81闭上眼，跟着心走。 2016.5.221不等苍天何时寂。 2016.6.41又是一年立夏，你的笑容依然在盛开吗 2016.6.1612勇敢是，当你还未开始就已知道自己会输。可你依然要去做，而且无论如何都要把它坚持到底。 2016.6.251每当落雪时，你要想起我。 2016.7.2123和她相遇的瞬间，我的人生就改变了。所见所闻所感，目之所及全都开始变得多姿多彩起来，全世界，都开始发光发亮。 2016.8.61用我一生 换你十年天真无邪 2016.8.191你亦如此,我复何求 2016.8.281借我怦然心动如往昔 2016.9.111Does the moon cease to exist when I don't look at it ? 2016.9.31我发誓等我有妹纸了一定洗心革面好好做人！ 2016.9.3012唯有黑色是真正染不黑的颜色，唯有绝情是永远伤不去的真情、 2016.10.11和记忆中的人恋爱，永远也不会失恋吧。 2016.10.111每一个不曾起舞的日子，都是对生命的辜负。 2016.10.201诠释孤独 2016.11.121你是我，一生的冒险。 2016.12.31我便是那罪恶之人。 2016.12.31念卿若狂，伴你岁岁安康。 2016.12.31看云起 2016.12.31愿不忘 2017.1.71世人攘攘皆为利往。 2017.1.231许是不知梦的缘故，流离之人追逐幻影… 2017.2.612任何有创意的喜悦，都会在自己所做事情的边界线上释放出来。 2017.4.41今夜月綺麗ですね 2017.4.51最大的感动莫过于把你带回家。 2017.4.141你在期待什么？ 2017.4.22123小小少年的表情，我看了整整一个梦，脸对着脸，我呼出的热气几乎融了他鼻尖上的白霜。我明白了，这个表情，就是不服气。 2017.5.61Science.Dream.Love 2017.5.2812345678910111213所谓青春，所谓梦想所谓青春并不是某个时间段而是一种精神状态热情，创造力，进取心，冒险精神所谓梦想并不是某种朦胧的向往而是一种生存态度无畏，勇敢，锲而不舍相信爱与美相信世界与自己都会变得更好 2017.6.31自己选择的路,跪着也要走完。 2017.6.41Nine point eight is my acceleration 2017.6.171意识流: 联想，印象，回忆，梦境，幻觉。 2017.6.21123人生如此复杂,机会多的像稠密图。尽管我们走不了最短路,但图仍是连通图。TLE之前,没有一个节点叫失败。 2017.6.231234整理,坚持,挑战.时间,旅行,只为不遗憾.简单,真诚,自然.珍惜,沟通,温暖.]]></content>
      <categories>
        <category>Diary</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[递归首次]]></title>
    <url>%2F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F%E9%80%92%E5%BD%92%E9%A6%96%E6%AC%A1%2F</url>
    <content type="text"><![CDATA[大水题, 用于递归第一次练习12345题目：f(x)=5 (x&gt;=0)f(x)=f(x+1)+f(x+2)+1 (x&lt;0)输入：0输出：5提交：Codevs1842 12345678910#include&lt;stdio.h&gt;int f(int x)&#123; return x&gt;=0? 5:f(x+1)+f(x+2)+1;&#125;int main()&#123; int x; scanf("%d",&amp;x); printf("%d\n",f(x)); return 0;&#125; ————————————————————–1234题目：输入一个整数n,求第n个Fibonacci数输入：3输出：2提交：Codevs1978 123456789#include&lt;iostream&gt;using namespace std;int f(int n)&#123; return n==1||n==2 ? 1: f(n-1)+f(n-2);&#125;int main()&#123; int n; cin&gt;&gt;n; cout&lt;&lt;f(n); return 0;&#125; ————————————————————–]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ADT抽象数据类型]]></title>
    <url>%2F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2FADT%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[一、定义1数据数据元素，数据关系以及相关的操作。 二、内容121. C++的Standard Template Library(模板库)2. 图论算法的分装 三、STL123456789&lt;algorithm&gt;&lt;vector&gt;&lt;set&gt;&lt;map&gt;&lt;stack&gt;&lt;queue&gt;&lt;deque&gt;&lt;list&gt;&lt;utility&gt;、&lt;functional&gt;、&lt;iterator&gt;、&lt;array&gt;、&lt;forward_list&gt;、&lt;unordered_map&gt;、&lt;memory&gt;、&lt;numeric&gt;、&lt;unordered_set&gt;、 四、12]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>ADT</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DFS]]></title>
    <url>%2F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2FDFS%2F</url>
    <content type="text"><![CDATA[一、定义123456789深度优先搜索算法（英语：Depth-First-Search，简称DFS）是一种用于遍历或搜索树或图的算法。沿着树的深度遍历树的节点，尽可能深的搜索树的分支。当节点v的所在边都己被探寻过，搜索将回溯到发现节点v的那条边的起始节点。这一过程一直进行到已发现从源节点可达的所有节点为止。如果还存在未被发现的节点，则选择其中一个作为源节点并重复以上过程，整个进程反复进行直到所有节点都被访问为止。属于盲目搜索。深度优先搜索是图论中的经典算法，利用深度优先搜索算法可以产生目标图的相应拓扑排序表，利用拓扑排序表可以方便的解决很多相关的图论问题，如最大路径问题等等。``` &gt;二、基本框架(待修改) ```c++1.访问顶点v2.依次从v的未被访问的邻接点出发，对图进行深度优先遍历；直至图中和v有路径相通的顶点都被访问3.若此时图中尚有顶点未被访问，则从一个未被访问的顶点出发，重新进行深度优先遍历，直到图中所有顶点均被访问过为止 三、用处121.DFS求通块(因为能够遍历图, )2. 四、本章节相关专题建议阅读顺序12341.求通块2.全排列3.回溯法4. 练习题 2017.5.61234561.Codevs1294 全排列 2.Codevs1295 N皇后问题 3.Codevs3895 环素数 4.Codevs1983 等式问题5.Codevs1018 单词接龙6.Codevs1026 逃跑的拉尔夫]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>搜索</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[子集生成问题]]></title>
    <url>%2F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F%E5%AD%90%E9%9B%86%E7%94%9F%E6%88%90%2F</url>
    <content type="text"><![CDATA[问：生成0~n所有的子集。答： 一、增量构造法123456789101112131415161718#include&lt;iostream&gt;using namespace std;int n, A[20];void dfs(int cur)&#123; for(int i = 1; i &lt; cur; i++)cout&lt;&lt;A[i]&lt;&lt;" "; cout&lt;&lt;"\n"; int s = A[cur-1]+1; for(int i = s; i &lt; n; i++)&#123; A[cur] = i; dfs(cur+1); &#125;&#125;int main()&#123; cin&gt;&gt;n; A[0] = -1; dfs(1); return 0;&#125; 二、位向量法123456789101112131415161718192021#include&lt;iostream&gt;using namespace std;int n, A[10];void dfs(int cur)&#123; if(cur == n)&#123; for(int i = 0; i &lt; n; i++) if(A[i])cout&lt;&lt;i&lt;&lt;" "; cout&lt;&lt;"\n"; &#125;else&#123; //A[cur] = 1; dfs(cur+1); A[cur] = 1; dfs(cur+1); A[cur] = 0; &#125;&#125;int main()&#123; cin&gt;&gt;n; dfs(0); return 0;&#125; 三、二进制法123456789101112#include&lt;iostream&gt;using namespace std;int main()&#123; int n; cin&gt;&gt;n; for(int i = 0; i &lt; (1&lt;&lt;n); i++)&#123; for(int j = 0; j &lt; n; j++) if(i&amp;(1&lt;&lt;j))cout&lt;&lt;j&lt;&lt;" "; cout&lt;&lt;"\n"; &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图论]]></title>
    <url>%2F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F%E5%9B%BE%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[图的基本概念： 一、图是什么1234567891011121.定义：图由顶点和边构成。顶点代表对象，边代表两个对象之间的连接关系。记为图G=(V(点集),E(边集));2.应用：图被应用于解决错综的网状关系的问题当中。 往往可以用之建立相关的模型套入相关算法以解决问题。``` &gt;二、图的分类```c++1.依据一：边没有指向性的叫做无向图(朋友关系,路线图)，边具有指向性的叫做有向图(数值大小,流程图)。2.依据二：根据边有无附加的属性(具有权值)，将图分为带权图，和不带权图。3.依据三：根据图是否有环(从一个顶点出发经过若干边可以回到该顶点)分为有环图和无欢图。4.依据四：任意两点之间都有路径的图叫做连通图，没有的叫非连通图。5.典型的无向图：没有圈的连通图叫做树，没有圈的非连通图叫做森林。6.典型的有向图：没有圈的有向图叫做DAG。 三、图的表示12340.背景：图作为与线性不同的另一种新的数据结构类型，为了能够在程序中对之进行处理，需要将之按某种方法存储下来。1.邻接矩阵：用一个二维数组表示(int e[maxn][maxn];)，e[i][j]表示顶点i与顶点j的距离，若不连通可以将之标记为inf。2.邻接表一：用链表存储从顶点0出发有到顶点1,2,3的边(int first[maxn],next[maxn];)，其中first[i]表示顶点i出发的第一条边,next[i]表示边i的下一条边(可以用-1表示不存在)。3.邻接表二：用向量存储从某顶点出发有到其余顶点的边(vector&lt;int&gt;G[maxn];)，其中G[i]存储了顶点i出发能够到达的其余边。 图的相关算法(本节为大纲,具体参见详细算法整理)： 四、图的搜索12 五、图的最短路12 五、最小生成树12 六、网络流12 图相关的数据结构(本节已全部移至数据结构章节) 七、树123456789101112二叉树最小堆最大堆并查集线段树AVL树平衡树红黑树树套树主席树树状数组二叉搜索树 八、图1有向无环图DAG]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[全排列问题]]></title>
    <url>%2F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F%E5%85%A8%E6%8E%92%E5%88%97%2F</url>
    <content type="text"><![CDATA[一、题目：12345678910题目：给出一个n, 请输出n的所有全排列。输入：3输出：1 2 31 3 22 1 32 3 13 1 23 2 1 二、分析1231.2.3. 三、提交1Codevs1294: http://codevs.cn/problem/1294/ 四、解答： 解法一、123456789101112131415161718192021#include&lt;cstdio&gt;int n, a[10];void dfs(int cur)&#123; if(cur == n)&#123; for(int i = 0; i &lt; n-1; i++)printf("%d ", a[i]); printf("%d\n", a[n-1]); &#125;else for(int i = 1; i &lt;= n; i++)&#123; bool ok = true; for(int j = 0; j &lt; cur; j++) if(a[j] == i)ok = false; if(ok)&#123; a[cur] = i; dfs(cur+1); &#125; &#125;&#125;int main()&#123; scanf("%d", &amp;n); dfs(0); return 0;&#125; 解法二、12345678910111213141516171819#include&lt;iostream&gt;using namespace std;int n, a[20], book[20];void dfs(int cur)&#123; if(cur == n)&#123; for(int i = 0; i &lt; n; i++)cout&lt;&lt;a[i]&lt;&lt;" "; cout&lt;&lt;"\n"; &#125;else for(int i = 1; i &lt;= n; i++)if(!book[i])&#123; a[cur] = i; book[i] = 1; dfs(cur+1); book[i] = 0; &#125;&#125;int main()&#123; cin&gt;&gt;n; dfs(0); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[漫水填充]]></title>
    <url>%2F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F%E6%B1%82%E9%80%9A%E5%9D%97%2F</url>
    <content type="text"><![CDATA[一、题型\分析1用于DFS求联通块 二、例题 poj248612345678910111213141516题目(待翻译)：Due to recent rains, water has pooled in various places in Farmer John's field, which is represented by a rectangle of N x M (1 &lt;= N &lt;= 100; 1 &lt;= M &lt;= 100) squares. Each square contains either water ('W') or dry land ('.'). Farmer John would like to figure out how many ponds have formed in his field. A pond is a connected set of squares with water in them, where a square is considered adjacent to all eight of its neighbors. Given a diagram of Farmer John's field, determine how many ponds he has.输入：10 12W........WW..WWW.....WWW....WW...WW..........WW..........W....W......W...W.W.....WW.W.W.W.....W..W.W......W...W.......W.输出：3 12345678910111213141516171819202122232425//poj2386 - Lake Counting#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int n, m, ans;string a[100];void dfs(int x, int y)&#123; for(int i = -1; i &lt;= 1; i++) for(int j = -1; j &lt;= 1; j++) if(x+i&gt;=0&amp;&amp;x+i&lt;n&amp;&amp;y+j&gt;=0&amp;&amp;y+j&lt;m &amp;&amp; a[x+i][y+j]=='W') &#123; a[x+i][y+j]='.'; dfs(x+i, y+j);&#125;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; cin.get(); for(int i = 0; i &lt; n; i++)getline(cin, a[i]); for(int i = 0; i &lt; n; i++) for(int j = 0; j &lt; m; j++) if(a[i][j] == 'W')&#123; dfs(i, j); ans++;&#125; cout&lt;&lt;ans&lt;&lt;"\n"; return 0;&#125; UVa5721234567891011题目：输入一个m行n列的字符矩阵，统计“@”组成多少个八连通块。输入：5 5****@*@@*@*@**@@@@*@@@**@0 0输出：2 1234567891011121314151617181920212223242526#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int m, n; string a[110];const int dx[] = &#123;0,0,-1,1,-1,1,-1,1&#125;;const int dy[] = &#123;1,-1,0,0,-1,1,1,-1&#125;;void dfs(int x, int y)&#123; a[x][y] = '*'; for(int i = 0; i &lt; 8; i++) if(x+dx[i]&gt;=0 &amp;&amp; x+dx[i]&lt;m &amp;&amp; y+dy[i]&gt;=0 &amp;&amp; y+dy[i]&lt;n &amp;&amp; a[x+dx[i]][y+dy[i]]=='@') dfs(x+dx[i],y+dy[i]);&#125;int main()&#123; while(cin&gt;&gt;m&gt;&gt;n &amp;&amp;m &amp;&amp;n)&#123; for(int i = 0; i &lt; m; i++)cin&gt;&gt;a[i]; int ans = 0; for(int i = 0; i &lt; m; i++) for(int j = 0; j &lt; n; j++) if(a[i][j] == '@')&#123; dfs(i,j); ans++;&#125; cout&lt;&lt;ans&lt;&lt;"\n"; &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[迭代加深]]></title>
    <url>%2F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F%E8%BF%AD%E4%BB%A3%E5%8A%A0%E6%B7%B1%2F</url>
    <content type="text"><![CDATA[一、定义12345678910``` 二、例```c++八数码问题题目：输入：输出：提交:Codevs1225 http://codevs.cn/problem/1225/ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;set&gt;#include&lt;cstring&gt;using namespace std;const int maxn = 1000000;typedef int State[9];State st[maxn], goal = &#123;1,2,3,8,0,4,7,6,5&#125;;int dist[maxn];set&lt;int&gt;vis;void init()&#123; vis.clear();&#125;bool insert(int x)&#123; int t = 0; for(int i = 0; i &lt; 9; i++)t = t*10+st[x][i]; if(vis.count(t))return false; vis.insert(t); return true;&#125;bool vis2[362880]; int fact[9];void init2()&#123; fact[0] = 1; for(int i = 1; i &lt; 9; i++)fact[i] = fact[i-1]*i;&#125;bool insert2(int x)&#123; int code = 0; for(int i = 0; i &lt; 9; i++)&#123; int cnt = 0; for(int j = i+1; j &lt; 9; j++)if(st[x][j] &lt; st[x][i])cnt++; code += fact[8-i]*cnt; &#125; if(vis2[code])return false; return vis2[code]=true;&#125;const int MAXHASHSIZE = 1000003;int head[MAXHASHSIZE], next[MAXHASHSIZE];void init3()&#123; memset(head, 0, sizeof(head));&#125;int hash(State&amp; s)&#123; int v = 0; for(int i = 0; i &lt; 9; i++)v = v*10+s[i]; return v % MAXHASHSIZE;&#125;bool insert3(int x)&#123; int h = hash(st[x]); int u = head[h]; while(u)&#123; bool ok = true; for(int i = 0; i &lt; 9; i++) if(st[u][i] != st[x][i])ok = false; if(ok) return false; u = next[u]; &#125; next[x] = head[h]; next[h] = x; return true;&#125;const int dx[] = &#123;0,0,1,-1&#125;;const int dy[] = &#123;-1,1,0,0&#125;;int bfs()&#123; init2(); int front = 1, rear = 2; while(front &lt; rear)&#123; bool ok = true; for(int i = 0; i &lt; 9; i++) if(st[front][i] != goal[i])ok = false; if(ok) return front; int z; for(z = 0; z &lt; 9; z++)if(!st[front][z])break; int x = z/3, y = z%3; for(int i = 0; i &lt; 4; i++)&#123; int newx=x+dx[i], newy=y+dy[i], newz=newx*3+newy; if(newx&gt;=0 &amp;&amp; newx&lt;3 &amp;&amp; newy&gt;=0 &amp;&amp; newy&lt;3)&#123; for(int j = 0; j &lt; 9; j++)st[rear][j] = st[front][j]; st[rear][newz] = st[front][z]; st[rear][z] = st[front][newz]; dist[rear] = dist[front]+1; if(insert2(rear))rear++; &#125; &#125; front++; &#125; return 0;&#125;int main()&#123; string str; cin&gt;&gt;str; for(int i = 0; i &lt; 9; i++)st[1][i] = str[i]-'0'; cout&lt;&lt;dist[bfs()]; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>搜索</tag>
        <tag>IDDFS</tag>
        <tag>迭代加深搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构]]></title>
    <url>%2F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[一、基础 抽象数据类型(ADT):表(list,hash), 栈(stack), 队列(queue) 树相关(Tree):二叉树, 堆(heap) 库(STL):排序(sort), 集合(set), 映射(map) 二、中级 树相关: 二叉搜索树, 线段树, 图相关: 并查集, 有向无环图(DAG),]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[回溯法]]></title>
    <url>%2F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F%E5%9B%9E%E6%BA%AF%E6%B3%95%2F</url>
    <content type="text"><![CDATA[一、定义12345678910将生成与检查有机的结合起来``` 二、N皇后问题```c++题目：在n×n格的棋盘上放置彼此不受攻击的n个皇后。按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。n后问题等价于再n×n的棋盘上放置n个皇后，任何2个皇后不妨在同一行或同一列或同一斜线上。输入：8输出：92提交：Codevs1295 http://codevs.cn/problem/1295/ 题解一、1234567891011121314151617181920#include&lt;cstdio&gt;int n, C[50], ans;void dfs(int cur)&#123; if(cur == n)ans++; else for(int i = 1; i &lt;= n; i++)&#123; bool ok = true; for(int j = 0; j &lt; cur; j++) if(C[j]==i || j-C[j]==cur-i || j+C[j]==cur+i)&#123; ok = false; break;&#125; if(ok)&#123; C[cur] = i; dfs(cur+1); &#125; &#125;&#125;int main()&#123; scanf("%d", &amp;n); dfs(0); printf("%d", ans); return 0;&#125; 题解二、12345678910111213141516171819#include&lt;iostream&gt;using namespace std;int n, vis[3][100], ans;void dfs(int cur)&#123; if(cur == n)ans++; else for(int i = 0; i &lt; n; i++)&#123; if(!vis[0][i] &amp;&amp; !vis[1][cur+i] &amp;&amp; !vis[2][cur-i+n])&#123; vis[0][i] = vis[1][cur+i] = vis[2][cur-i+n] = 1; dfs(cur+1); vis[0][i] = vis[1][cur+i] = vis[2][cur-i+n] = 0; &#125; &#125;&#125;int main()&#123; cin&gt;&gt;n; dfs(0); cout&lt;&lt;ans; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
</search>
